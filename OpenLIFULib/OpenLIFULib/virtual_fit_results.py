import slicer
from slicer import vtkMRMLTransformNode
from typing import Optional, Iterable

def add_virtual_fit_result(
    transform_node: vtkMRMLTransformNode,
    target_id: str,
    session_id: Optional[str] = None,
    approval_status: bool = False,
    rank: int = 1,
    replace = False,
) -> vtkMRMLTransformNode:
    """Clone a transform node and set it to be a "virtual fit result".
    This means the transform node clone will be named appropriately
    and will have a bunch of attributes set on it so that we can identify it
    later as a virtual fit result.

    Args:
        transform_node: The transform node to clone in order to create this virtual
            fit result. Probably this is the transducer transform node after a transducer
            got sent through the virtual fit process.
        target_id: The ID of the target for which the virtual fit was computed.
            For example in a session-based workflow this should be the id of the
            target openlifu.Point.
        session_id: The ID of the openlifu.Session during which the virtual fit took place.
            If not provided then it is assumed the virtual fit took place without
            a session -- in such a workflow it is probably up to the user what they
            want to do with the virtual fit result transform node since the virtual fit
            result has no openlifu session to be saved into.
        approval_status: The approval status of the virtual fit result
        rank: The rank of the virtual fit result in the ordering, from best to worst,
            of virtual fit results for this target. This can be needed because multiple candidate
            transforms can get generated by a virtual fitting algorithm.
        replace: Whether to replace any existing virtual fit results that have the
            same session ID, target ID, and rank. If this is off, then an error is raised
            in the event that there is already a matching virtual fit result in the scene.

    Returns: The newly created virtual fit result transform node
    """

    existing_vf_result_nodes = get_virtual_fit_result_nodes(target_id=target_id, session_id=session_id)
    if session_id is None:
        existing_vf_result_nodes = filter(
            lambda t : t.GetAttribute("VF:sessionID") is None,
            existing_vf_result_nodes,
        ) # if a sessionless VF result is being added, conflict should only occur among other sessionless results, hence this filtering
    for existing_vf_result_node in existing_vf_result_nodes:
        existing_vf_result_node_rank = int(existing_vf_result_node.GetAttribute("VF:rank"))
        if existing_vf_result_node_rank == rank:
            if replace:
                slicer.mrmlScene.RemoveNode(existing_vf_result_node)
            else:
                raise RuntimeError("There is already a virtual fit result node for this target+session+rank and replace is False")

    shNode = slicer.vtkMRMLSubjectHierarchyNode.GetSubjectHierarchyNode(slicer.mrmlScene)
    itemIDToClone = shNode.GetItemByDataNode(transform_node)
    clonedItemID = slicer.modules.subjecthierarchy.logic().CloneSubjectHierarchyItem(shNode, itemIDToClone)
    virtual_fit_result : vtkMRMLTransformNode = shNode.GetItemDataNode(clonedItemID)

    virtual_fit_result.SetName(f"VF {target_id} {rank}")
    virtual_fit_result.SetAttribute("isVirtualFitResult", "1")
    virtual_fit_result.SetAttribute("VF:targetID", target_id)
    virtual_fit_result.SetAttribute("VF:approvalStatus", "1" if approval_status else "0")
    virtual_fit_result.SetAttribute("VF:rank", str(rank))
    if session_id is not None:
        virtual_fit_result.SetAttribute("VF:sessionID", session_id)

    return virtual_fit_result

def get_virtual_fit_result_nodes(
    target_id : Optional[str] = None,
    session_id : Optional[str] = None,
    sort : bool = False,
    best_only : bool = False,
) -> Iterable[vtkMRMLTransformNode]:
    """Retrieve a list of all virtual fit result nodes, filtered and sorted as desired.

    Args:
        target_id: filter for only this target ID
        session_id: filter for only this session ID
        sort: sort by rank, from best rank to worst  (ascending rank value)
        best_only: filter for only the rank 1 virtual fit results

    Returns the list of matching virtual fit result transform nodes that are currently in the scene.
    """
    if sort and best_only:
        raise ValueError("It does not make sense to both sort by rank and retrieve only rank 1 results.")

    vf_result_nodes : Iterable[vtkMRMLTransformNode] = [
        t for t in slicer.util.getNodesByClass('vtkMRMLTransformNode') if t.GetAttribute("isVirtualFitResult") == "1"
    ]

    if session_id is not None:
        vf_result_nodes = filter(lambda t : t.GetAttribute("VF:sessionID") == session_id, vf_result_nodes)

    if target_id is not None:
        vf_result_nodes = filter(lambda t : t.GetAttribute("VF:targetID") == target_id, vf_result_nodes)

    if best_only:
        vf_result_nodes = filter(lambda t : int(t.GetAttribute("VF:rank")) == 1, vf_result_nodes)

    if sort:
        vf_result_nodes = sorted(vf_result_nodes, key = lambda t : int(t.GetAttribute("VF:rank")))

    return vf_result_nodes

def get_best_virtual_fit_result_node(
    target_id : str,
    session_id : Optional[str] = None,
) -> vtkMRMLTransformNode:
    """Retrieve the best virtual fit result node for the given target, raising an exception if there isn't a unique one.

    Args:
        target_id: target ID for which to retrieve the unique virtual fit result
        session_id: optional session ID to help resolve possible ambiguities, when there is a session involved
    """
    vf_result_nodes = list(get_virtual_fit_result_nodes(target_id=target_id, session_id=session_id))
    if len(vf_result_nodes) < 1:
        raise RuntimeError(
            f"There are no virtual fit result nodes for target {target_id}"
            + (f" and session {session_id}" if session_id is not None else "")
        )

    if len(vf_result_nodes) > 1:
        raise RuntimeError(
            f"There are {len(vf_result_nodes)} virtual fit result nodes for target {target_id}"
            + (f" and session {session_id}" if session_id is not None else "")
        )

    return vf_result_nodes[0]

def clear_virtual_fit_results(
    target_id: str,
    session_id: Optional[str] = None,
) -> None:
    """Remove all virtual fit results nodes from the scene that match the given target and session id.

    Args:
        target_id: target ID that needs to match for a virtual fit result to be removed.
        session_id: optional session ID. If not provided
            then **only virtual fit results with no session ID are removed**!
    """

    nodes_to_remove = get_virtual_fit_result_nodes(target_id=target_id, session_id=session_id)
    
    # If session_is None, then at this point nodes_to_remove is not filtered for session ID
    # So here we specifically filter for nodes that are have *no* session id:
    if session_id is None:
        nodes_to_remove = filter(
            lambda t : t.GetAttribute("VF:sessionID") is None,
            nodes_to_remove,
        )
    
    for node in nodes_to_remove:
        slicer.mrmlScene.RemoveNode(node)
